# advprog-modul6
## Refleksimas
Commit 1:  
Saya mengimplementasikan function handle_connection. Function handle_connection ini akan memberikan raw http request yang dikirim oleh pengguna. Function tersebut juga menerima parameter object yakni TcpStream yang akan dikasih referencesnya ke BufReader. Kemudian Http Request akan dipisahkan berdasarkan split newline atau CRLF, setelah itu diunwrap dan hasil dari unwrap akan diiterasi dan diambil valuenya pada setiap baris yang tidak kosong dan akan dicetak di layar  

Commit 2:  
Function handle_connection yang baru akan mengirimkan raw HTTP Response dengan status 200 OK, di mana respon tersebut menyertakan data HTML sehingga jika HTTP Request dikirimkan melalui browser, pengguna dapat langsung melihat tampilan respon server, serta menyertakan header Content-Length untuk menentukan panjang body respon yang dikirimkan  

Commit 3:  
Function handle_connection yang telah dimodifikasi kini mengirimkan HTTP Response berdasarkan status dari HTTP Request yang diterima. Jika request yang masuk adalah GET request dengan URI / dan menggunakan versi HTTP/1.1, maka server akan merespons dengan mengirimkan HTML hello.html. Sebaliknya, jika request tidak memenuhi kriteria tersebut, server akan mengembalikan halaman 404.html. Proses identifikasinya cukup sederhana, yaitu dengan mengambil baris pertama dari raw HTTP Request lalu mengeceknya terhadap string "GET / HTTP/1.1". Dengan mekanisme ini, handle_connection mulai berfungsi layaknya routing sederhana, di mana server mengembalikan halaman HTML yang sesuai berdasarkan request yang diterima. Namun, saat pertama kali mengimplementasikan kode ini mengikuti Chapter 20 dari dokumentasi yang dijadikan referensi, ditemukan adanya duplikasi kode pada bagian pengecekan request untuk menentukan apakah harus mengembalikan hello.html atau tidak. Untuk mengatasi masalah ini, dilakukan refactoring dengan memisahkan status_line serta nama file HTML ke dalam variabel yang nilainya ditentukan berdasarkan request yang diterima.  

Commit 4:  
Dengan modifikasi pada handle_connection agar menangani GET request ke URI /sleep, setiap kali seseorang mengakses URI tersebut, pengguna lain yang ingin mengakses URI / harus menunggu hingga proses sebelumnya selesai sebelum mendapatkan respons dari server. Hal ini terjadi karena handle_connection masih berjalan dalam mode single-threaded, sehingga setiap request diproses satu per satu secara berurutan. Karena hal itu, misal terdapat bagian dalam handle_connection yang membutuhkan waktu eksekusi lama seperti ketika menangani /sleep yang menyebabkan server "tidur" selama 10 detik sebelum merespons dengan HTML hello.html, maka semua request lain yang datang dalam rentang waktu tersebut harus menunggu hingga proses saat ini selesai. Dalam skenario dengan banyak pengguna yang mengakses /sleep, server akan mengalami keterlambatan yang signifikan dalam menangani request lainnya, membuat respon untuk halaman lain menjadi sangat lambat.  

Commit 5:  
Sekarang, handle_connection tidak lagi berjalan dalam mode single-threaded, melainkan menggunakan multi-threaded menggunakan bantuan ThreadPool, sebuah struct yang berisi beberapa Worker dan sebuah Sender untuk mengeksekusi handle_connection saat ada koneksi masuk. ThreadPool memiliki Sender yang digunakan untuk mengirimkan Job, yaitu fungsi yang akan dieksekusi dengan parameter tertentu hanya sekali dan aman untuk dikirim ke thread lain. Fungsi execute dalam ThreadPool mengirimkan fungsi yang diterima sebagai parameter ke Sender, lalu Sender meneruskannya ke Worker. Setiap Worker memiliki Receiver yang menerima Job dari Sender dan dibungkus dalam Arc serta Mutex, memungkinkan kepemilikan bersama oleh banyak Worker, tetapi hanya satu Worker yang dapat mengambil Job dalam satu waktu. Saat Worker menerima Job, thread tempat Worker berjalan akan dikunci agar tidak menerima Job lain, lalu Job dieksekusi, dan setelah selesai, thread dibuka kembali agar bisa menerima tugas berikutnya. Dengan mekanisme ini, jika ada satu request yang membutuhkan waktu lama untuk diproses, request lain tetap bisa dieksekusi oleh thread lain dalam ThreadPool (misalnya, jika ada 4 thread, maka hingga 4 request bisa diproses secara bersamaan).  

Commit Bonus:  
Perubahan dari fungsi new yang menggunakan assert!(size > 0) untuk langsung "panic" pada input yang tidak valid menjadi fungsi build yang mengembalikan Result<ThreadPool, &'static str> memungkinkan penanganan error secara eksplisit, sehingga meskipun terjadi kesalahan input, aplikasi tidak langsung berhenti melainkan memberikan kesempatan untuk penanganan error yang lebih fleksibel dan aman.